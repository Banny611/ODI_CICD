<?xml version="1.0" encoding="UTF-8"?>
<SunopsisExport>
<Admin RepositoryVersion="05.02.02.09" IsLegacyIdCompatible="false" />
<Encryption algorithm="AES" keyLength="128" exportKeyHash="l526rpovH3MC/2c4+nSQBkA1tofuYrAtg3aWcY+XkfE=" keyVect="sDWVJ/pZRpz834ruuVYhFA==" exportKeySalt="78710653-9fd0-409b-beb7-a20675d31f78" containsCipherText="false"/>
<Object class="com.sunopsis.dwg.dbobj.SnpTrt">
		<Field name="CleanupOnError" type="java.lang.String">null</Field>
	<Field name="CompType" type="java.lang.String">null</Field>
	<Field name="DelegateClass" type="java.lang.String">null</Field>
	<Field name="DelegateScript" type="java.lang.String">null</Field>
	<Field name="ExpectedAstClass" type="java.lang.String">null</Field>
	<Field name="ExtVersion" type="java.lang.String">null</Field>
	<Field name="FirstDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="FirstUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[23967aac-f1d6-432d-966e-1635d712c186]]></Field>
	<Field name="IndChange" type="java.lang.String"><![CDATA[U]]></Field>
	<Field name="IndExcludeExUnitBegin" type="java.lang.String">null</Field>
	<Field name="IndExcludeExUnitEnd" type="java.lang.String">null</Field>
	<Field name="IndExcludeExUnitMain" type="java.lang.String">null</Field>
	<Field name="IndExcludeMapBegin" type="java.lang.String">null</Field>
	<Field name="IndExcludeMapCleanup" type="java.lang.String">null</Field>
	<Field name="IndExcludeMapEnd" type="java.lang.String">null</Field>
	<Field name="IndGenerateLoad" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndIsHidden" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndJrnMethod" type="java.lang.String"><![CDATA[S]]></Field>
	<Field name="IndSuppSetBased" type="java.lang.String">null</Field>
	<Field name="IntgType" type="java.lang.String">null</Field>
	<Field name="IntVersion" type="com.sunopsis.sql.DbInt"><![CDATA[2]]></Field>
	<Field name="IsConcurrent" type="java.lang.String">null</Field>
	<Field name="IsSeeded" type="java.lang.String">null</Field>
	<Field name="IBaseCompKm" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IFolder" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IProject" type="com.sunopsis.sql.DbInt"><![CDATA[1]]></Field>
	<Field name="IScBaseTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IScOrigTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IScTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ITrt" type="com.sunopsis.sql.DbInt"><![CDATA[300]]></Field>
	<Field name="ITxtDelTxt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ITxtTrtTxt" type="com.sunopsis.sql.DbInt"><![CDATA[5985]]></Field>
	<Field name="KimMultiDserver" type="java.lang.String"><![CDATA[1]]></Field>
	<Field name="KmDefault" type="java.lang.String"><![CDATA[1]]></Field>
	<Field name="KmLang" type="java.lang.String">null</Field>
	<Field name="KmSrcLang" type="java.lang.String">null</Field>
	<Field name="KmSrcTechno" type="java.lang.String"><![CDATA[HIVE]]></Field>
	<Field name="KmTechno" type="java.lang.String">null</Field>
	<Field name="KmVersion" type="java.lang.String"><![CDATA[35]]></Field>
	<Field name="LastDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="LastUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="LkmType" type="java.lang.String">null</Field>
	<Field name="LChecksum" type="com.sunopsis.sql.DbInt"><![CDATA[196383959]]></Field>
	<Field name="LCode" type="java.lang.String">null</Field>
	<Field name="OggJkm" type="java.lang.String">null</Field>
	<Field name="OrdFolder" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ProcType" type="java.lang.String">null</Field>
	<Field name="ProdAstType" type="java.lang.String">null</Field>
	<Field name="RepGuid" type="java.lang.String">null</Field>
	<Field name="RepVersion" type="java.lang.String">null</Field>
	<Field name="ScriptPath" type="java.lang.String">null</Field>
	<Field name="ScOrigTrtTag" type="java.lang.String">null</Field>
	<Field name="Subtype" type="java.lang.String">null</Field>
	<Field name="TrtName" type="java.lang.String"><![CDATA[RKM Hive]]></Field>
	<Field name="TrtType" type="java.lang.String"><![CDATA[KR]]></Field>
	<Field name="VariableDefs" type="java.lang.String">null</Field>
	<Field name="VLastDate" type="java.sql.Timestamp">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpTxtHeader">
		<Field name="Enc" type="java.lang.String">null</Field>
	<Field name="EncKey" type="java.lang.String">null</Field>
 <Field name="EncKeyVect" type="java.lang.String">null</Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[874fda22-1cf4-4ad6-80a6-723da9687f47]]></Field>
	<Field name="ITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5985]]></Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[107]]></Field>
	<Field name="SqlIndGrp" type="java.lang.String"><![CDATA[0]]></Field>
 <Field name="Txt" type="java.lang.String"><![CDATA[COMPONENT NAME: RKM HIVE
AUTHOR: Oracle

DESCRIPTION
	Reverse engineering Knowledge Module to retrieve the tables and columns from Hive. 

REQUIREMENTS
	- Hive JDBC driver (and required jars) must be installed into ODI Studio/ Agent 
	(Make sure that the connection test for the Hive DataServer works.)

BASIC CONFIGURATION
	- Import this knowledge module as global knowledge module or into one of your projects.
	- Create a model, and choose the reverse context as well as the knowledge module in the "reverse" tab.
	- Execute the reverse engineering and follow up the steps in the logs

LIMITATIONS
	The mask of tables to reverse must not be empty, and at least contain the '%' character.
	The tab Selective reverse cannot be used with this knowledge module.

]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpOrigTxt">
		<Field name="GlobalId" type="java.lang.String">null</Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[107]]></Field>
	<Field name="OrigineName" type="java.lang.String"><![CDATA[Edit Command]]></Field>
	<Field name="SnpsCol" type="java.lang.String"><![CDATA[I_TXT_TRT_TXT]]></Field>
	<Field name="SnpsTable" type="java.lang.String"><![CDATA[SNP_TRT]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpLineTrt">
		<Field name="AlwaysExe" type="java.lang.String"><![CDATA[1]]></Field>
	<Field name="BrpId" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColConnectId" type="java.lang.String">null</Field>
	<Field name="ColContextCode" type="java.lang.String">null</Field>
	<Field name="ColIndCommit" type="java.lang.String">null</Field>
	<Field name="ColIsolLevel" type="java.lang.String">null</Field>
	<Field name="ColITxt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColLanguage" type="java.lang.String">null</Field>
	<Field name="ColLschemaName" type="java.lang.String">null</Field>
	<Field name="ColTechno" type="java.lang.String"><![CDATA[HIVE]]></Field>
	<Field name="DefConnectId" type="java.lang.String">null</Field>
	<Field name="DefContextCode" type="java.lang.String">null</Field>
	<Field name="DefIndCommit" type="java.lang.String">null</Field>
	<Field name="DefIsolLevel" type="java.lang.String">null</Field>
	<Field name="DefITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5986]]></Field>
	<Field name="DefLanguage" type="java.lang.String">null</Field>
	<Field name="DefLschemaName" type="java.lang.String">null</Field>
	<Field name="DefTechno" type="java.lang.String"><![CDATA[SUNOPSIS_API]]></Field>
	<Field name="ExeChannel" type="java.lang.String">null</Field>
	<Field name="FirstDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="FirstUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[4a07e37f-4c72-414e-ac80-df7a3a4305c6]]></Field>
	<Field name="IndErr" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogFinalCmd" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogNb" type="java.lang.String">null</Field>
	<Field name="ILineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[3313]]></Field>
	<Field name="IRefLineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IRefTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ITrt" type="com.sunopsis.sql.DbInt"><![CDATA[300]]></Field>
	<Field name="KcmAk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmCond" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmErrDel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmJoin" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmNull" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmPk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimDrvdSel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrnPop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmCreate" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmDrop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmExtend" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmInstall" type="java.lang.String">null</Field>
	<Field name="KjmLock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmPurge" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetInstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetUninstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmTableOrder" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUninstall" type="java.lang.String">null</Field>
	<Field name="KjmUnlock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUnsubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmAfterInt" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="LastDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="LastUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="LineType" type="java.lang.String">null</Field>
	<Field name="LogLevDet" type="java.lang.String"><![CDATA[4]]></Field>
	<Field name="MapTaskType" type="java.lang.String">null</Field>
	<Field name="OrdTrt" type="com.sunopsis.sql.DbInt"><![CDATA[51]]></Field>
	<Field name="SqlName" type="java.lang.String"><![CDATA[Reset MetaData]]></Field>
	<Field name="SupportedSubtypes" type="java.lang.String">null</Field>
	<Field name="VariableDefs" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpTxtHeader">
		<Field name="Enc" type="java.lang.String">null</Field>
	<Field name="EncKey" type="java.lang.String">null</Field>
 <Field name="EncKeyVect" type="java.lang.String">null</Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[4af7cb0d-daa0-40d9-9c56-fbb755a791a7]]></Field>
	<Field name="ITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5986]]></Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[102]]></Field>
	<Field name="SqlIndGrp" type="java.lang.String"><![CDATA[2]]></Field>
 <Field name="Txt" type="java.lang.String"><![CDATA[<% if (isODI12cOrLater) { /*if ODI 12C*/ %>
  OdiReverseResetTable -MODEL=<%=odiRef.getModel("GLOBAL_ID")%>
<%} else { /*if ODI 10g or 11g*/ %>
  OdiReverseResetTable -MODEL=<%=odiRef.getModel("ID")%>
<%}%>]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpOrigTxt">
		<Field name="GlobalId" type="java.lang.String">null</Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[102]]></Field>
	<Field name="OrigineName" type="java.lang.String"><![CDATA[Target Technology]]></Field>
	<Field name="SnpsCol" type="java.lang.String"><![CDATA[DEF_I_TXT]]></Field>
	<Field name="SnpsTable" type="java.lang.String"><![CDATA[SNP_LINE_TRT]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpLineTrt">
		<Field name="AlwaysExe" type="java.lang.String"><![CDATA[1]]></Field>
	<Field name="BrpId" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColConnectId" type="java.lang.String">null</Field>
	<Field name="ColContextCode" type="java.lang.String">null</Field>
	<Field name="ColIndCommit" type="java.lang.String">null</Field>
	<Field name="ColIsolLevel" type="java.lang.String">null</Field>
	<Field name="ColITxt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColLanguage" type="java.lang.String">null</Field>
	<Field name="ColLschemaName" type="java.lang.String">null</Field>
	<Field name="ColTechno" type="java.lang.String"><![CDATA[HIVE]]></Field>
	<Field name="DefConnectId" type="java.lang.String">null</Field>
	<Field name="DefContextCode" type="java.lang.String">null</Field>
	<Field name="DefIndCommit" type="java.lang.String">null</Field>
	<Field name="DefIsolLevel" type="java.lang.String">null</Field>
	<Field name="DefITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5987]]></Field>
	<Field name="DefLanguage" type="java.lang.String">null</Field>
	<Field name="DefLschemaName" type="java.lang.String">null</Field>
	<Field name="DefTechno" type="java.lang.String"><![CDATA[GROOVY]]></Field>
	<Field name="ExeChannel" type="java.lang.String">null</Field>
	<Field name="FirstDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="FirstUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[ef48b183-5eba-4824-8d36-b3ab6f4de263]]></Field>
	<Field name="IndErr" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogFinalCmd" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogNb" type="java.lang.String">null</Field>
	<Field name="ILineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[3314]]></Field>
	<Field name="IRefLineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IRefTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ITrt" type="com.sunopsis.sql.DbInt"><![CDATA[300]]></Field>
	<Field name="KcmAk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmCond" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmErrDel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmJoin" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmNull" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmPk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimDrvdSel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrnPop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmCreate" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmDrop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmExtend" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmInstall" type="java.lang.String">null</Field>
	<Field name="KjmLock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmPurge" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetInstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetUninstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmTableOrder" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUninstall" type="java.lang.String">null</Field>
	<Field name="KjmUnlock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUnsubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmAfterInt" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="LastDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="LastUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="LineType" type="java.lang.String">null</Field>
	<Field name="LogLevDet" type="java.lang.String"><![CDATA[4]]></Field>
	<Field name="MapTaskType" type="java.lang.String">null</Field>
	<Field name="OrdTrt" type="com.sunopsis.sql.DbInt"><![CDATA[71]]></Field>
	<Field name="SqlName" type="java.lang.String"><![CDATA[Start the Reverse]]></Field>
	<Field name="SupportedSubtypes" type="java.lang.String">null</Field>
	<Field name="VariableDefs" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpTxtHeader">
		<Field name="Enc" type="java.lang.String">null</Field>
	<Field name="EncKey" type="java.lang.String">null</Field>
 <Field name="EncKeyVect" type="java.lang.String">null</Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[8654a520-cae8-4703-861a-6aa511a9b6a3]]></Field>
	<Field name="ITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5987]]></Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[102]]></Field>
	<Field name="SqlIndGrp" type="java.lang.String"><![CDATA[2]]></Field>
 <Field name="Txt" type="java.lang.String"><![CDATA[srcCx = odiRef.getJDBCConnection("SRC")
srcSchema ='''<%=odiRef.getInfo("SRC_SCHEMA")%>'''

trgCx = odiRef.getJDBCConnection("DEST")
<% if (isODI12cOrLater) { %>
imod    =  '''<%=odiRef.getModel("GLOBAL_ID")%>'''
<%} else { %>
imod    =  '''<%=odiRef.getModel("ID")%>'''
<%}%>
tabpat  = [ 	'''<%=odiRef.getModel("REV_OBJ_PATT")%>''',  '''<%=odiRef.getModel("REV_OBJ_TYPE")%>''',  '''<%=odiRef.getModel("REV_ALIAS_LTRIM")%>''' ] 

 
// START THE REVERSE 
<% if (isODI12cOrLater) { %>
logger = odiRef.getLogger();
rev.initialize(imod, (String[])tabpat.toArray(), srcCx, srcSchema, trgCx, logger) 
<%} else {%>
logfile = <$startCapture();$><%=odiRef.getOption("LOG_FILE_NAME")%><$=getQuotedMLString(endCapture())$>
uselog = <%=odiRef.getOption("USE_LOG")%>==1 
rev.initialize(imod, (String[])tabpat.toArray(), srcCx, srcSchema, trgCx, uselog, logfile) 
<%}%>
rev.startReverse() 
rev.endReverse() 

srcCx.close()
trgCx.close()]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpLineTrt">
		<Field name="AlwaysExe" type="java.lang.String"><![CDATA[1]]></Field>
	<Field name="BrpId" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColConnectId" type="java.lang.String">null</Field>
	<Field name="ColContextCode" type="java.lang.String">null</Field>
	<Field name="ColIndCommit" type="java.lang.String">null</Field>
	<Field name="ColIsolLevel" type="java.lang.String">null</Field>
	<Field name="ColITxt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColLanguage" type="java.lang.String">null</Field>
	<Field name="ColLschemaName" type="java.lang.String">null</Field>
	<Field name="ColTechno" type="java.lang.String"><![CDATA[HIVE]]></Field>
	<Field name="DefConnectId" type="java.lang.String">null</Field>
	<Field name="DefContextCode" type="java.lang.String">null</Field>
	<Field name="DefIndCommit" type="java.lang.String">null</Field>
	<Field name="DefIsolLevel" type="java.lang.String">null</Field>
	<Field name="DefITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5988]]></Field>
	<Field name="DefLanguage" type="java.lang.String">null</Field>
	<Field name="DefLschemaName" type="java.lang.String">null</Field>
	<Field name="DefTechno" type="java.lang.String"><![CDATA[SUNOPSIS_API]]></Field>
	<Field name="ExeChannel" type="java.lang.String">null</Field>
	<Field name="FirstDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="FirstUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[13fb67ca-b0db-4af0-b410-9993c28ebfea]]></Field>
	<Field name="IndErr" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogFinalCmd" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogNb" type="java.lang.String">null</Field>
	<Field name="ILineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[3315]]></Field>
	<Field name="IRefLineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IRefTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ITrt" type="com.sunopsis.sql.DbInt"><![CDATA[300]]></Field>
	<Field name="KcmAk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmCond" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmErrDel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmJoin" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmNull" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmPk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimDrvdSel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrnPop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmCreate" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmDrop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmExtend" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmInstall" type="java.lang.String">null</Field>
	<Field name="KjmLock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmPurge" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetInstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetUninstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmTableOrder" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUninstall" type="java.lang.String">null</Field>
	<Field name="KjmUnlock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUnsubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmAfterInt" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="LastDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="LastUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="LineType" type="java.lang.String">null</Field>
	<Field name="LogLevDet" type="java.lang.String"><![CDATA[3]]></Field>
	<Field name="MapTaskType" type="java.lang.String">null</Field>
	<Field name="OrdTrt" type="com.sunopsis.sql.DbInt"><![CDATA[81]]></Field>
	<Field name="SqlName" type="java.lang.String"><![CDATA[Set MetaData]]></Field>
	<Field name="SupportedSubtypes" type="java.lang.String">null</Field>
	<Field name="VariableDefs" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpTxtHeader">
		<Field name="Enc" type="java.lang.String">null</Field>
	<Field name="EncKey" type="java.lang.String">null</Field>
 <Field name="EncKeyVect" type="java.lang.String">null</Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[5a96fa80-c234-42e5-b9ad-280620d30f11]]></Field>
	<Field name="ITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5988]]></Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[102]]></Field>
	<Field name="SqlIndGrp" type="java.lang.String"><![CDATA[2]]></Field>
 <Field name="Txt" type="java.lang.String"><![CDATA[<% if (isODI12cOrLater) { /*if ODI 12C*/ %>
OdiReverseSetMetaData "-MODEL=<%=odiRef.getModel("GLOBAL_ID")%>" 
<%} else { /*if ODI 10g or 11g*/%>
OdiReverseSetMetaData -MODEL=<%=odiRef.getModel("ID")%> -USE_TABLE_NAME_FOR_UPDATE=true
<%}%>]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpLineTrt">
		<Field name="AlwaysExe" type="java.lang.String"><![CDATA[1]]></Field>
	<Field name="BrpId" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColConnectId" type="java.lang.String">null</Field>
	<Field name="ColContextCode" type="java.lang.String">null</Field>
	<Field name="ColIndCommit" type="java.lang.String">null</Field>
	<Field name="ColIsolLevel" type="java.lang.String">null</Field>
	<Field name="ColITxt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ColLanguage" type="java.lang.String">null</Field>
	<Field name="ColLschemaName" type="java.lang.String">null</Field>
	<Field name="ColTechno" type="java.lang.String"><![CDATA[HIVE]]></Field>
	<Field name="DefConnectId" type="java.lang.String">null</Field>
	<Field name="DefContextCode" type="java.lang.String">null</Field>
	<Field name="DefIndCommit" type="java.lang.String">null</Field>
	<Field name="DefIsolLevel" type="java.lang.String">null</Field>
	<Field name="DefITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5989]]></Field>
	<Field name="DefLanguage" type="java.lang.String">null</Field>
	<Field name="DefLschemaName" type="java.lang.String">null</Field>
	<Field name="DefTechno" type="java.lang.String"><![CDATA[GROOVY]]></Field>
	<Field name="ExeChannel" type="java.lang.String">null</Field>
	<Field name="FirstDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="FirstUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[44a76539-2497-42de-8378-885acce989ba]]></Field>
	<Field name="IndErr" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogFinalCmd" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="IndLogNb" type="java.lang.String">null</Field>
	<Field name="ILineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[3316]]></Field>
	<Field name="IRefLineTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="IRefTrt" type="com.sunopsis.sql.DbInt"><![CDATA[null]]></Field>
	<Field name="ITrt" type="com.sunopsis.sql.DbInt"><![CDATA[300]]></Field>
	<Field name="KcmAk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmCond" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmErrDel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmJoin" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmNull" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KcmPk" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimDrvdSel" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KimJrnPop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmCreate" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmDrop" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmExtend" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmInstall" type="java.lang.String">null</Field>
	<Field name="KjmLock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmPurge" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetInstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSetUninstall" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmSubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmTableOrder" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUninstall" type="java.lang.String">null</Field>
	<Field name="KjmUnlock" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KjmUnsubscribe" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmAfterInt" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmIdx" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="KlmJrn" type="java.lang.String"><![CDATA[0]]></Field>
	<Field name="LastDate" type="java.sql.Timestamp"><![CDATA[2021-08-27 16:47:37.0]]></Field>
	<Field name="LastUser" type="java.lang.String"><![CDATA[SUPERVISOR]]></Field>
	<Field name="LineType" type="java.lang.String">null</Field>
	<Field name="LogLevDet" type="java.lang.String"><![CDATA[5]]></Field>
	<Field name="MapTaskType" type="java.lang.String">null</Field>
	<Field name="OrdTrt" type="com.sunopsis.sql.DbInt"><![CDATA[1]]></Field>
	<Field name="SqlName" type="java.lang.String"><![CDATA[Create Java Classes]]></Field>
	<Field name="SupportedSubtypes" type="java.lang.String">null</Field>
	<Field name="VariableDefs" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpTxtHeader">
		<Field name="Enc" type="java.lang.String">null</Field>
	<Field name="EncKey" type="java.lang.String">null</Field>
 <Field name="EncKeyVect" type="java.lang.String">null</Field>
	<Field name="GlobalId" type="java.lang.String"><![CDATA[903f8af7-cbd6-4521-b744-d01235ec63c6]]></Field>
	<Field name="ITxt" type="com.sunopsis.sql.DbInt"><![CDATA[5989]]></Field>
	<Field name="ITxtOrig" type="com.sunopsis.sql.DbInt"><![CDATA[102]]></Field>
	<Field name="SqlIndGrp" type="java.lang.String"><![CDATA[2]]></Field>
 <Field name="Txt" type="java.lang.String"><![CDATA[<% isODI12cOrLater = !odiRef.getInfo("ODI_MAJOR_VERSION").contains("ODI_MAJOR_VERSION"); %>
<$

/* Begin of BSh code gen extensions */

out2 = null;
buffer = null;

startCapture() {
    out2 = out;
    buffer = new ByteArrayOutputStream();
    out = new PrintWriter( buffer );
}

endCapture() {
    out.flush();
    out.close();
    captured = buffer.toString();
    out = out2;
    return captured;
}

getQuotedMLString( s ) {
// escape tripple single quotes
// escape backslashes
    return 
        "'''" + 
        s.replace(""+(char)92, ""+(char)92+(char)92)
        .replace( "'''", ""+(char)92+"'"+(char)92+"'"+(char)92+"'") +
        "'''";
}

/* End of BSh code gen extensions */

$>


/* Begin of RkmHive.java */

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Formatter;
import java.util.regex.Pattern;
import java.util.regex.Matcher;


import java.util.logging.Level;
<% if (isODI12cOrLater) { %>
import com.sunopsis.dwg.snpreference.OdiRefLogger;
<%}%>

    /**
     * class Log {
     * @return
     * Creates a log file and traces information
     */
    public class Log {
        protected boolean printToScreen = false;
        protected boolean append = false;
        protected boolean useLog = true;
        protected FileOutputStream out; 
        protected PrintStream p;
        
        public Log( String pLogfilename, boolean pUselog, boolean pAppend, boolean pPrinttoscreen) throws FileNotFoundException {
            printToScreen = pPrinttoscreen;
            useLog = pUselog;

            out = new FileOutputStream(pLogfilename,pAppend);
            p = new PrintStream( out );
        }

        public void log (Level level, String rec) {
            if (useLog) {
                String l = (new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")).format(new Date()) + " - " + rec;
                p.println( l );
                p.flush();
                try {
                    out.flush();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (printToScreen) { System.out.println( l ); };
            }
        }
        public void format(String pFormat, Object... args) {
            record( String.format( pFormat, args) );
        }
    }

    public class MyStack {
      private int maxSize;
      private String[] stackArray;
      private int top;
      public MyStack(int s) {
        maxSize = s;
        stackArray = new String[maxSize];
        top = -1;
      }
      public void push(String j) {
        stackArray[++top] = j;
      }
      public String pop() {
        return stackArray[top--];
      }
      public String peek() {
        return stackArray[top];
      }
      public boolean isEmpty() {
        return (top == -1);
      }
      public boolean isFull() {
        return (top == maxSize - 1);
      }
    }


public class RkmHive {

    // Hive data type driver constants
    protected static final String HIVE_DATATYPE_BIGINT   = "bigint";
    protected static final String HIVE_DATATYPE_INT      = "int";
    protected static final String HIVE_DATATYPE_SMALLINT = "smallint";
    protected static final String HIVE_DATATYPE_TINYINT  = "tinyint";
    protected static final String HIVE_DATATYPE_FLOAT    = "float";
    protected static final String HIVE_DATATYPE_DOUBLE   = "double";
    protected static final String HIVE_DATATYPE_STRING   = "string";
    protected static final String HIVE_DATATYPE_BOOLEAN  = "boolean";
    protected static final String HIVE_DATATYPE_BINARY   = "binary";
    protected static final String HIVE_DATATYPE_TIMESTAMP= "timestamp";
    protected static final String HIVE_DATATYPE_ARRAY    = "array";
    protected static final String HIVE_DATATYPE_MAP      = "map";
    protected static final String HIVE_DATATYPE_STRUCT   = "struct";
    protected static final String HIVE_DATATYPE_CHAR   = "char";
    protected static final String HIVE_DATATYPE_DATE      = "date";
    protected static final String HIVE_DATATYPE_DECIMAL = "decimal";
    protected static final String HIVE_DATATYPE_UNIONTYPE  = "uniontype";
    protected static final String HIVE_DATATYPE_VARCHAR    = "varchar";

    
    // SQL commands
<% if (isODI12cOrLater) { %>
    protected static final String SQL_INSERT_TABLE     = "insert into SNP_REV_TABLE (MOD_GUID,TABLE_NAME,RES_NAME,TABLE_ALIAS,TABLE_DESC_C,IND_SHOW,TABLE_TYPE) values (?,?,?,?,?,?,?)";
    protected static final String SQL_UPDATE_TABLE_TYPE  = "update SNP_REV_TABLE set IND_HIVE_MANAGED = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_STORAGE_TYPE  = "update SNP_REV_TABLE set IND_HIVE_NATIVE = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_ROW_FORMAT  = "update SNP_REV_TABLE set HIVE_ROW_FORMAT = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_STORAGE_FORMAT  = "update SNP_REV_TABLE set I_TABLE_FORMAT_TYPE = ?, INPUT_FORMAT = ?, OUTPUT_FORMAT = ?, HIVE_LOCATION = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_SERDE  = "update SNP_REV_TABLE set SERDE = ?, SERDE_PROP = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_DELIMITED  = "update SNP_REV_TABLE set FILE_SEP_FIELD = ?, FILE_ESC_CHAR = ?, FILE_SEP_ROW = ?, FILE_SEP_COLL = ?, FILE_SEP_MAP = ?, FILE_NULL_VALUE = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_BUCKET  = "update SNP_REV_TABLE set HIVE_BUCKETS = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_PROP  = "update SNP_REV_TABLE set TABLE_PROP = ? where MOD_GUID = ? and TABLE_NAME = ?";
    protected static final String SQL_UPDATE_TABLE_STORAGE_PROP  = "update SNP_REV_TABLE set STORAGE_HANDLER = ?, STORAGE_PROP = ? where MOD_GUID = ? and TABLE_NAME = ?";

    protected static final String SQL_INSERT_COLUMNS   = "insert into SNP_REV_COL (MOD_GUID,TABLE_NAME,COL_NAME,COL_HEADING,COL_DESC_C,DT_DRIVER,POS,LONGC,SCALEC,BYTES,COL_MANDATORY,CHECK_FLOW,CHECK_STAT,DATA_FORMAT) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
    protected static final String SQL_UPDATE_COLUMNS_PAR = "update SNP_REV_COL set IND_HIVE_PARTITION = ? where MOD_GUID = ? and TABLE_NAME = ? and COL_NAME = ?";
    protected static final String SQL_UPDATE_COLUMNS_CLU = "update SNP_REV_COL set IND_HIVE_CLUSTER = ? where MOD_GUID = ? and TABLE_NAME = ? and COL_NAME = ?";
    protected static final String SQL_UPDATE_COLUMNS_SORT = "update SNP_REV_COL set HIVE_SORTBY_POS = ? where MOD_GUID = ? and TABLE_NAME = ? and COL_NAME = ?";
<%} else {%>
    protected static final String SQL_INSERT_TABLE     = "insert into SNP_REV_TABLE (I_MOD,TABLE_NAME,RES_NAME,TABLE_ALIAS,TABLE_DESC_C,IND_SHOW,TABLE_TYPE) values (?,?,?,?,?,?,?)";
    protected static final String SQL_INSERT_TABLE_FF  = "insert into SNP_REV_TABLE_FFV (I_MOD,TABLE_NAME,FF_CODE,NUM_VALUE) values (?,?,?,?)";
    protected static final String SQL_INSERT_COLUMNS   = "insert into SNP_REV_COL (I_MOD,TABLE_NAME,COL_NAME,COL_HEADING,COL_DESC_C,DT_DRIVER,POS,LONGC,SCALEC,BYTES,COL_MANDATORY,CHECK_FLOW,CHECK_STAT) values (?,?,?,?,?,?,?,?,?,?,?,?,?)";
    protected static final String SQL_INSERT_COLUMN_FF = "insert into SNP_REV_COL_FFV (I_MOD,TABLE_NAME,COL_NAME,FF_CODE,NUM_VALUE) values (?,?,?,?,?)";
<%}%>

    // RegEx Constants for extracting additional metadata from extended table information 
    static protected String HIVE_MD_TABLEDEF_REGEX        = "^\\QTable(\\E.*";
    static protected String HIVE_MD_PARTITIONDEF_REGEX    = "\\QpartitionKeys:[\\E(.*?)\\]";
    static protected String HIVE_MD_PARTITIONCOLUMN_REGEX = "\\QFieldSchema(name:\\E(.*?)\\Q, type:\\E(.*?)\\Q, comment:\\E(.*?)\\)";
    static protected String HIVE_MD_BUCKETDEF_REGEX       = "\\QbucketCols:[\\E(.*?)\\]";
    static protected String HIVE_MD_BUCKETCOLUMN_REGEX    = "(\\w+)";
    static protected String HIVE_MD_BUCKETS_REGEX         = "\\QnumBuckets:\\E([0-9]+)";
    static protected String HIVE_MD_SORTDEF_REGEX         = "\\QsortCols:[\\E(.*?)\\]";
    static protected String HIVE_MD_SORTCOLUMN_REGEX      = "\\QOrder(col:\\E(.*?)\\Q, order:\\E(.*?)\\)";
    static protected String HIVE_MD_TABLETYPE_REGEX	  = "\\QtableType:\\E(.*?)\\)";
    static protected String HIVE_MD_INPUTFORMAT_REGEX	  = "\\QinputFormat:\\E(.*?)\\,";
    static protected String HIVE_MD_OUTPUTFORMAT_REGEX	  = "\\QoutputFormat:\\E(.*?)\\,";
    static protected String HIVE_MD_SERDE_REGEX	          = "\\QserializationLib:\\E(.*?)\\,";
    static protected String HIVE_MD_LOCATION_REGEX	  = "\\Qlocation:\\E(.*?)\\,";
    static protected String HIVE_MD_SERDEINFO_REGEX       = "\\QSerDeInfo(\\E(.*?)\\),";
    static protected String HIVE_MD_SERDE_PROP_REGEX      = "\\Qparameters:{\\E(.*?)\\}";
    static protected String HIVE_MD_STORAGE_HANDLER_REGEX      = "\\Qstorage_handler=\\E(.*?)\\}";

<% if (isODI12cOrLater) { %>
    OdiRefLogger logger;
<%} else {%>
    Log logger;
<%}%>
    Connection srcCx, repoCx;
    String srcSchema;
    String srcTabFilter, aliasRemoveChars;
    String[] tabType;
<% if (isODI12cOrLater) { %>
    String iMod;
<%} else {%>
    String iMod;
<%}%>
    private DatabaseMetaData metadata; 
    private ArrayList listOfPartitioningCols;
    private int numOfPartitionColumns;


    //Dummy constructor
    public RkmHive() {};

    /**
     * 
     *                     Constructor:
                            iMod:        I_MODEL/MODEL_GUID value for the current Model to be reversed
                            tabPattern:  Table pattern info [Filter, TableType, AliasRemoveChars]
                            srcConnect:  Source connection
                            repoConnect: Repository connection 

                    Example:
                            src     = odiRef.getJdbcConnection(SRC)
                            repo    = odiRef.getJdbcConnection(DEST)
                            imod    = 5111/"KLJoiu78hKFRAEJ8976"
                            tabpat  = ['%', 'T', 'TRG_']
                            rev     = SnpsReverse(imod, tabpat, src, repo, 1, logfile)
                            rev.startReverse(getcolumns=1, getkeys=1, getfks=1)
                            rev.endReverse()
     * @param iMod
     * @param tabPattern
     * @throws FileNotFoundException 
     */
    public void initialize(String piMod, String[] tabPattern, Connection pSrcConnect, String pSrcSchema, Connection pRepoConnect, Boolean pUseLog, String pLogFileName) throws FileNotFoundException {    
        logger = new Log(pLogFileName, pUseLog, false, true);
        initialize( piMod, tabPattern, pSrcConnect, pSrcSchema, pRepoConnect, logger );
    }

    public void initialize(String piMod, String[] tabPattern, Connection pSrcConnect, String pSrcSchema, Connection pRepoConnect, Object/*Logger*/ logger_in) throws FileNotFoundException {    
        logger = logger_in;
        logger.log(Level.INFO, "Reverse Started.");
        iMod = piMod;

        // Do some basic tests
        if (pSrcConnect == null) 
            throw new OdiKMException("ODIKM-HIVE-10000", "ODIKM-HIVE-10000: Failure to open JDBC connection. Please test DataServer connection." );
        if (pRepoConnect == null) 
            throw new OdiKMException("ODIKM-HIVE-10005", "ODIKM-HIVE-10005: Failure to open Repository JDBC connection. Please test DataServer connection");

        // Connect to the source database:
        srcSchema  = (pSrcSchema.length() == 0)?null:pSrcSchema;
        srcCx = pSrcConnect;

        // Connect to the Repostory database:
        repoCx = pRepoConnect;

        // Table Pattern information:
        srcTabFilter = tabPattern[0];
        tabType = getTableType(tabPattern[1]);
        aliasRemoveChars = tabPattern[2];
        logger.log(Level.INFO, "Reverse Options: Model " + iMod);
        logger.log(Level.INFO, "                 srcSchema " + srcSchema);
        logger.log(Level.INFO, "                 Tabfilter " + srcTabFilter);
        logger.log(Level.INFO, "                 TabType " + tabType);

        // intialize source metadata
        try {
            metadata = srcCx.getMetaData();
            logger.log(Level.INFO, "Driver Name:    " + metadata.getDriverName().toString());
            logger.log(Level.INFO, "Driver Version: " + metadata.getDriverVersion());
        } catch (SQLException e) {
            logger.log(Level.INFO, "Exception when initializing source metadata");
            e.printStackTrace();
        }
    }

    /**
     * 
                    Public method to start a reverse
                    set getcolumns, getkeys and getfks flags according to
                    what you want to reverse
     * @param getcolumns
     * @param getkeys
     * @param getfks
     * @throws SQLException 
     */
    public void startReverse() throws SQLException {
        getTables(true, true, true);
    }

    /**
     * 
                    Public Method that should be called to release all opened connections
     */
    public void endReverse(){
        /* Connection management is handled by ODI and should not be done inside RKM
                logger.log(Level.INFO, "Disconnecting from Source.");
                if (!srcCx.isClosed()) { srcCx.close() }
                logger.log(Level.INFO, "Disconnecting from Repository2");
                if (!self.repoCx.isClosed()) { repoCx.close() }
         */
        logger.log(Level.INFO, "Reverse End.");                
    }

    /*
     * Returns an empty string, if s is null;
     * Returns a string no longer than maxLen characters;
     */
    protected String restrictString( String s, int maxLen ) {
        String s2 = (s == null)?"":s;
        s2 = s2.substring(0, (s2.length()>maxLen)?maxLen:s2.length());
        return s2;
    }


    /**
     * 
                    Starts the Reverse of the Tables
                    retrieves columns, keys and fks according to the flags sent as parameters
     * @throws SQLException 
     */
    protected void getTables(boolean getcolumns, boolean getkeys, boolean getextendedinfo) throws SQLException {
        logger.log(Level.INFO, String.format("*** Getting %s List ***", tabType));
        ResultSet tlst = metadata.getTables(null, srcSchema, srcTabFilter, tabType);
        String sqltxt = SQL_INSERT_TABLE;
        PreparedStatement psTables = repoCx.prepareStatement(sqltxt);
        while (tlst.next()) {
            String tableCat = "";
            try{ tableCat = tlst.getString("TABLE_CAT"); } finally {};
            String tableSchem = "";
            try{ tableSchem = tlst.getString("TABLE_SCHEM"); }
            catch (SQLException e) {
                /* Due to HIVE-4549 getString("TABLE_SCHEM") causes s SQLException in some 
                   Hive versions. To deal with this problam, we need to consume the exception
                   and call getString("TABLE_SCHEMA") afterwards */
                logger.log(Level.WARNING,
                    String.format(
                        "SQLException caught during getString(TABLE_SCHEM):\n" +
                        "This is likely caused by HIVE-4549.\n" +
                        "\nMessage: %s\nStack trace:\n%s",
                        e.getMessage(),
                        org.apache.commons.lang.exception.ExceptionUtils.getStackTrace(e)
                    )
                 );
                 try{ tableSchem = tlst.getString("TABLE_SCHEMA"); } finally {};
            }
            finally {};
            String tableName = "";
            try{ tableName = tlst.getString("TABLE_NAME"); } finally {};
            String remarks = tlst.getString("REMARKS");
            String ttype = tlst.getString("TABLE_TYPE");
            String tableType = getTableType2(ttype);
            // Set table type to T for external tables. Otherwise reverse will not import them.
            if (tableType.equals("X")) tableType = "T";
            String tableAlias = restrictString((aliasRemoveChars.length()>0)?tableName.replace(aliasRemoveChars, ""):tableName,128);

            logger.log(Level.INFO, String.format("Table: %s,%s,%s,%s,%s,%s,%s (%s)", iMod, tableName, tableName, tableAlias, remarks, "1", tableType,ttype));
            psTables.clearParameters();
            <% if(isODI12cOrLater) { %>
            psTables.setString(1,iMod);
            <% } else { %>
            psTables.setInt(1,Integer.valueOf(iMod));
            <% } %>
            psTables.setString(2,tableName);
            psTables.setString(3,tableName);
            psTables.setString(4,tableAlias);
            psTables.setString(5,remarks);
            psTables.setString(6,"1");
            psTables.setString(7,tableType);
            psTables.executeUpdate();

            numOfPartitionColumns = 0;
            listOfPartitioningCols = new ArrayList();
            
            // Get the columns
            if (getcolumns) getColumns(tableName);
            // Get FlexFields
            if (getextendedinfo) getExtendedInfo(tableName);
        }

        psTables.close();
        tlst.close();
        repoCx.commit();
    }


    /**
     * Retrieves columns definition of a specified table
     * @throws SQLException 
     * @throws NumberFormatException 
     */
    protected void getColumns(String tableName) throws NumberFormatException, SQLException {
        logger.log(Level.INFO, "  *** Getting Columns for table: " + tableName);
        ResultSet clst = metadata.getColumns(null, srcSchema, tableName, "%");
        String sqltxt = SQL_INSERT_COLUMNS;
        PreparedStatement ps = repoCx.prepareStatement(sqltxt);
        int colPos = 0;

        while (clst.next()) {
            String colTable = clst.getString("TABLE_NAME");
            String colName = clst.getString("COLUMN_NAME");
            // Is this a partioning column?
            if (listOfPartitioningCols.contains(colName)) {
                // Paritioning column
                // Is this the first partitioning column? 
                // (so we have already processed all standard columns)
                if (colPos > numOfPartitionColumns) {
                    // This is the first partitioning column. 
                    // So we need to place it first.
                    colPos = 1;
                } else {
                    // This is the next partitioning column
                    colPos++;
                }
            } else {
                // Standard column
            	  colPos = numOfPartitionColumns + clst.getInt("ORDINAL_POSITION");
            }
            // coldt     = clst.getString("DATA_TYPE");
            String colTypeName = clst.getString("TYPE_NAME");
            String rawDataFormat = colTypeName.replace(" ", "");
            String dataFormat;
            colTypeName = (colTypeName.startsWith(HIVE_DATATYPE_ARRAY))?"COMPLEX":colTypeName; 
            colTypeName = (colTypeName.startsWith(HIVE_DATATYPE_MAP))?"COMPLEX":colTypeName; 
            colTypeName = (colTypeName.startsWith(HIVE_DATATYPE_STRUCT))?"COMPLEX":colTypeName; 
            colTypeName = (colTypeName.startsWith(HIVE_DATATYPE_UNIONTYPE))?"COMPLEX":colTypeName;
            if (!colTypeName.equals("COMPLEX"))
              dataFormat = "";
            else 
              dataFormat = constructDataFormat(colName, rawDataFormat);
              
            String colRemark = clst.getString("REMARKS");
            String colHeading = colName;
            String colSizeStr = clst.getString("COLUMN_SIZE");
            int colSize = Integer.parseInt(colSizeStr);
            int colDec  = clst.getInt("DECIMAL_DIGITS");
            int colLen  = clst.getInt("CHAR_OCTET_LENGTH");
            int colNull = 0;
            String colIsnull = "0";

            logger.log(Level.INFO, String.format("   Column: %s, %s, %d, %s, %d, %d, %d, %s, %s", colName, colTypeName, colPos, colSize, colDec, colLen, colNull, colIsnull, dataFormat));

            insertColumn(ps, colPos, colTable, colName, colTypeName, colRemark, dataFormat, colSize, colDec, colLen);
        }
        clst.close();
        ps.close();
        repoCx.commit();
    }
  
    private String constructDataFormat(String colName, String rawDataFormat) {
      MyStack myStack = new MyStack(1000);
      StringBuffer dataFormat = new StringBuffer();
      int currIndex = 0;
      int preIndex = 0;
      char tempChar;
      while (currIndex < rawDataFormat.length()) {
        tempChar = rawDataFormat.charAt(currIndex);
        if (tempChar == '<') {
          String currDataType = rawDataFormat.substring(preIndex, currIndex);
          if (currDataType.equalsIgnoreCase("array")) {
            dataFormat.append("{\"name\":\"" + colName + "_array" + preIndex + "\",\"type\":\"array\"," + "\"items\":");
          } else if (currDataType.equalsIgnoreCase("struct")) {
            dataFormat.append("{\"name\":\"" + colName + "_object" + preIndex + "\",\"type\":\"object\"," + "\"fields\":[");
          } else if (currDataType.equalsIgnoreCase("uniontype")) {
            dataFormat.append("{\"name\":\"" + colName + "_uniontype" + preIndex + "\",\"type\":[");
          } else if (currDataType.equalsIgnoreCase("map")) {
            currIndex++;
            preIndex = currIndex;
            char mapChar = rawDataFormat.charAt(currIndex);
            while (mapChar != ',')
              mapChar = rawDataFormat.charAt(++currIndex);
            currIndex++;
            preIndex = currIndex;
            mapChar = rawDataFormat.charAt(currIndex);
            while (mapChar != '>')
              mapChar = rawDataFormat.charAt(++currIndex);
            dataFormat.append("{\"type\":\"map\",\"values\":\""+ rawDataFormat.substring(preIndex, currIndex) + "\"}");
          }
          currIndex++;
          preIndex = currIndex;
          //System.out.println("push data type = " + currDataType + ", currIndex = " + currIndex + ", preIndex = " + preIndex);
          if (!currDataType.equalsIgnoreCase("map"))
            myStack.push(currDataType);
        } else if (tempChar == '>') {
          if (preIndex != currIndex) {
            if (myStack.peek().equals(":")) {
              dataFormat.append("\"type\":\"" + rawDataFormat.substring(preIndex, currIndex) + "\"}");
              myStack.pop();
            } else
              dataFormat.append("\"type\":\"" + rawDataFormat.substring(preIndex, currIndex) + "\"");
          }
          String correspondingDataType = myStack.pop();
          if (correspondingDataType.equalsIgnoreCase("struct"))
            dataFormat.append("]}");
          else if (correspondingDataType.equalsIgnoreCase("array"))
            dataFormat.append("}");
          else if (correspondingDataType.equalsIgnoreCase("uniontype"))
            dataFormat.append("]}");
          else
            dataFormat.append("}");
          currIndex++;
          preIndex = currIndex;
        } else if (tempChar == ':') {
          dataFormat.append("{\"name\":\"" + rawDataFormat.substring(preIndex, currIndex) + "\",");
          currIndex++;
          myStack.push(":");
          preIndex = currIndex;
        } else if (tempChar == ',') {
          if (myStack.peek().equals(":")) {
            myStack.pop();
            dataFormat.append("\"type\":\"" + rawDataFormat.substring(preIndex, currIndex).toLowerCase() + "\"},");
          } else {
            dataFormat.append("\"" + rawDataFormat.substring(preIndex, currIndex).toLowerCase() + "\",");
          }
          currIndex++;
          preIndex = currIndex;
        } else
          currIndex++;
      }

      String newDataFormat = dataFormat.toString();
      newDataFormat = newDataFormat.replace("binary", "bytes");
      newDataFormat = newDataFormat.replace("varchar", "string");
      newDataFormat = newDataFormat.replace("char", "string");
      newDataFormat = newDataFormat.replace("date", "string");
      newDataFormat = newDataFormat.replace("decimal", "float");
      newDataFormat = newDataFormat.replace("bigint", "long");
      newDataFormat = newDataFormat.replace("smallint", "integer");
      newDataFormat = newDataFormat.replace("tinyint", "integer");
      newDataFormat = newDataFormat.replace("int", "integer");
      newDataFormat = newDataFormat.replace("timestamp", "string");
      return newDataFormat;
    }
  
       
 
    private void insertColumn(PreparedStatement ps, int colPos,
            String colTable, String colName, String colTypeName,
            String colRemark, String dataFormat,
            int colSize, int colDec, int colLen) throws SQLException {

        // Insert column into SNP_REV_COLUMN
        ps.clearParameters();
        //protected static final String SQL_INSERT_COLUMNS   = 
        //"insert into SNP_REV_COL (I_MOD,TABLE_NAME,COL_NAME,COL_HEADING,COL_DESC,DT_DRIVER,POS,LONGC,SCALEC,BYTES,COL_MANDATORY,CHECK_FLOW,CHECK_STAT) values (?,?,?,?,?,?,?,?,?,?,?,?,?)";

        <% if(isODI12cOrLater) { %>
        ps.setString(1, iMod);     // I_MOD
        <% } else { %>
        ps.setInt(1,Integer.valueOf(iMod));
        <% } %>
        ps.setString(2,restrictString(colTable,128));                // TABLE_NAME
        ps.setString(3,restrictString(colName,128));                 // COLUMN_NAME
        ps.setString(4,restrictString(colName,128));                 // COL_HEADING
        ps.setString(5,colRemark);               // COL_REMARK
        ps.setString(6,colTypeName);                                 // DT_DRIVER
        ps.setInt(7,colPos);                                         // POS
        if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_DECIMAL)) {        
            ps.setInt(8,colSize);                                         // LONGC 
            ps.setInt(9,colDec);                                         // SCALEC
            ps.setInt(10,colLen);                                         // BYTES
        } else if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_CHAR)) {        
            ps.setInt(8,colSize);                                        // LONGC 
            ps.setNull(9, colDec);                   // SCALEC
            ps.setInt(10,colLen);                                       // BYTES
        } else if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_VARCHAR)) {        
            ps.setInt(8,colSize);                                        // LONGC 
            ps.setNull(9, colDec);                   // SCALEC
            ps.setInt(10,colLen);                                       // BYTES
        } else if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_BOOLEAN)) {        
            ps.setInt(8,1);                                          // LONGC 
            ps.setNull(9, java.sql.Types.INTEGER);                   // SCALEC
            ps.setInt(10,1);                                         // BYTES
        } else if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_BINARY)) {        
            ps.setInt(8,1);                                          // LONGC 
            ps.setNull(9, java.sql.Types.INTEGER);                      // SCALEC
            ps.setInt(10,1);                                         // BYTES
        } else if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_TIMESTAMP)) {        
            ps.setInt(8,0);                                         // LONGC 
            ps.setInt(9,9);                                         // SCALEC
            ps.setInt(10,29);                                         // BYTES
        } else if (colTypeName.toLowerCase().equals(HIVE_DATATYPE_DATE)) {        
            ps.setInt(8,0);                                         // LONGC 
            ps.setInt(9,9);                                         // SCALEC
            ps.setInt(10,29);                                         // BYTES
        } else { 
            ps.setNull(8, java.sql.Types.INTEGER);                   // LONGC 
            ps.setNull(9, java.sql.Types.INTEGER);                   // SCALEC
            ps.setNull(10, java.sql.Types.INTEGER);                  // BYTES
        };
        ps.setString(11,"0");
        ps.setString(12,"0");
        ps.setString(13,"0");
        //ps.setString(14,dataFormat);
        Clob clobDataFormat = repoCx.createClob();
        clobDataFormat.setString(1, dataFormat);
        ps.setClob(14,clobDataFormat);
        ps.executeUpdate();
    }


    /**
     * Returns the JDBC table Type according to the Sunopsis TYpe
     * @return
     */
    protected String[] getTableType(String tabPattern) {
        ArrayList tableType = new ArrayList();

        for (String snpstype : tabPattern.split(";")) {
            if (snpstype.equals("T"))       { tableType.add("TABLE"); 
                                              tableType.add("MANAGED_TABLE"); 
                                              tableType.add("EXTERNAL TABLE"); 
                                              tableType.add("EXTERNAL_TABLE"); 
                                            }
            else if (snpstype.equals("V"))  { tableType.add("VIEW");
                                              tableType.add("VIRTUAL_VIEW");
                                            };
            else if (snpstype.equals("ST")) tableType.add("SYSTEM TABLE");
            else if (snpstype.equals("AT")) tableType.add("ALIAS");
            else if (snpstype.equals("SY")) tableType.add("SYNONYM");
            else if (snpstype.equals("QE")) tableType.add("QUEUE");
            else if (snpstype.equals("GT")) tableType.add("GLOBAL TEMPORARY");
            else if (snpstype.equals("LT")) tableType.add("LOCAL TEMPORARY");
            else tableType.add("X");
        }
        //String []strArray = new String[tableType.size()];
        return (String[]) tableType.toArray();
    }

    /**
     * Returns the ODI table Type according to the JDBC TYpe
     * @return
     */
    protected String getTableType2(String tableType) {
        if (tableType.equals("TABLE"))            return("T");
        if (tableType.equals("MANAGED_TABLE"))    return("T");
        if (tableType.equals("EXTERNAL TABLE"))   return("T");
        if (tableType.equals("EXTERNAL_TABLE"))   return("T");
        if (tableType.equals("VIEW"))             return("V");
        if (tableType.equals("VIRTUAL_VIEW"))     return("V");
        if (tableType.equals("SYSTEM TABLE"))     return("ST");
        if (tableType.equals("ALIAS"))            return("AT");
        if (tableType.equals("SYNONYM"))          return("SY");
        if (tableType.equals("QUEUE"))            return("QE");
        if (tableType.equals("GLOBAL TEMPORARY")) return("GT");
        if (tableType.equals("LOCAL TEMPORARY"))  return("LT");
        return("X");
    }


    protected getExtendedInfo(String tableName) throws SQLException {

        Pattern p = Pattern.compile( HIVE_MD_TABLEDEF_REGEX );
        Matcher m;
        Statement stmt = srcCx.createStatement();
        String qualifiedTableName = srcSchema + "." + tableName;
        // Due to 
        // HIVE-1977 DESCRIBE TABLE syntax doesn't support specifying a database qualified table name
        // we have to use the unqualified table name for now
        //ResultSet lst = stmt.executeQuery( "describe extended " + tableName );
        // Work-around removed, as fixed in Hive CDH 4.4
        ResultSet lst = stmt.executeQuery( "describe extended " + qualifiedTableName );
        String extendedTableInfo = ""; 
        // Iterate over lines of metadata returned to locate the line containing the detailed table information
        String s ="";
        try {
            while (lst.next()) {
                s = lst.getString(2);
                s = (s==null)?"":s;
                                
                // Due to CDH-14264
                // we have to concatenate the first field of the next row,
                // if the metadata got cut at the line delimiter
                if (s.endsWith("line.delim=")) {
                    lst.next();
                    String s2 = lst.getString(1);
                    s2 = (s2==null)?"":s2;
                    s += s2;
                }
                
                m = p.matcher( s );
                if (m.find()) {
                    extendedTableInfo = s;
                    logger.log(Level.INFO, String.format( "Extended Table information for table %s: >>>%s<<<", qualifiedTableName, extendedTableInfo));
                }
            }
        } catch (SQLException e) {
            // This catch is a work-around for HIVE-2381 SQLException thrown when the resultset becomes empty. 
        } finally {};
        lst.close();
        stmt.close();

        // Extract table type definition
        p = Pattern.compile( HIVE_MD_TABLETYPE_REGEX );
        m = p.matcher( extendedTableInfo );
        if (m.find()) {
          String tableTypeDef = m.group(1);
          logger.log(Level.INFO, String.format( "Table Type Definition found: >>>%s<<<", tableTypeDef));
        
          // Set Table Type
          if (tableTypeDef != null) {
            String sqltxt = SQL_UPDATE_TABLE_TYPE;
            PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
            psTable.clearParameters();
            psTable.setString(2,iMod);
            psTable.setString(3,tableName);
            if (tableTypeDef.equals("MANAGED_TABLE"))
              psTable.setString(1,"1");
            else
              psTable.setString(1, "0");
            psTable.executeUpdate();
            psTable.close();
          }
        } 
        
        //Extract table properties
        p = Pattern.compile( HIVE_MD_SERDE_PROP_REGEX );
        m = p.matcher( extendedTableInfo );
        String tableProp = null;
        while (m.find()) {
          tableProp = m.group(1);
          logger.log(Level.INFO, String.format( "Table Property found: >>>%s<<<", tableProp));        
        }
        if (tableProp != null) {
          tableProp = constructProp(tableProp);
          logger.log(Level.INFO, String.format( "New Table Property found: >>>%s<<<", tableProp));
          
          String sqltxt = SQL_UPDATE_TABLE_PROP;
          PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
          psTable.clearParameters();
          psTable.setString(2,iMod);
          psTable.setString(3,tableName);
          Clob clobTableProp = repoCx.createClob();
          clobTableProp.setString(1, tableProp);
          psTable.setClob(1,clobTableProp);            
          psTable.executeUpdate();
          psTable.close();
        }

        // set Storage Type
        p = Pattern.compile( HIVE_MD_STORAGE_HANDLER_REGEX );
        m = p.matcher( extendedTableInfo );
        boolean isNative = true;
        String storageHandler = null;
        if (m.find()) { //non native
          isNative = false;
          storageHandler = m.group(1);
          logger.log(Level.INFO, String.format( "Storage Handler found: >>>%s<<<", storageHandler));
      
          String sqltxt = SQL_UPDATE_TABLE_STORAGE_TYPE;
          PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
          psTable.clearParameters();
          psTable.setString(2,iMod);
          psTable.setString(3,tableName);
          psTable.setString(1,"0");
          psTable.executeUpdate();
          psTable.close();                 
        } else { // native
          String sqltxt = SQL_UPDATE_TABLE_STORAGE_TYPE;
          PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
          psTable.clearParameters();
          psTable.setString(2,iMod);
          psTable.setString(3,tableName);
          psTable.setString(1,"1");
          psTable.executeUpdate();
          psTable.close();
        }
            
        // set Row Format
        p = Pattern.compile( HIVE_MD_SERDE_REGEX );
        m = p.matcher( extendedTableInfo );
        int tableFormatType;
        String rowFormat;
        String serdeDef;
        if (m.find()) {
          serdeDef = m.group(1);
          logger.log(Level.INFO, String.format( "Serde Definition found: >>>%s<<<", serdeDef));
          
          if (serdeDef.indexOf("LazySimpleSerDe") > 0 || serdeDef.indexOf("MetadataTypedColumnsetSerDe") > 0) {
            rowFormat = "DL";
            tableFormatType = 8; //delimited
          } else if (serdeDef.equals("org.apache.hadoop.hive.serde2.avro.AvroSerDe")) {  
            rowFormat = "BI";
            tableFormatType = 1;
          } else if (serdeDef.equals("org.apache.hadoop.hive.ql.io.orc.OrcSerde")) {
            rowFormat = "BI";
            tableFormatType = 4;
          } else if (serdeDef.equals("org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe") /*|| serdeDef.equals("parquet.hive.serde.ParquetHiveSerDe")*/) {
            rowFormat = "BI";
            tableFormatType = 5;
          } else if (serdeDef.equals("org.apache.hadoop.hive.serde2.OpenCSVSerde") || serdeDef.equals("org.apache.hadoop.hive.serde2.RegexSerDe")) {
            rowFormat = "BI";
            tableFormatType = 8;
          } else if (serdeDef.indexOf("JsonSerDe") > 0) {
            rowFormat = "SD";
            tableFormatType = 3;
          } else {
            rowFormat = "SD";
            tableFormatType = 8;
          }
        }
        
        // Extract inputformat definition
        p = Pattern.compile( HIVE_MD_INPUTFORMAT_REGEX );
        m = p.matcher( extendedTableInfo );
        String inputFormat;
        if (m.find()) {
          inputFormat = m.group(1);
          logger.log(Level.INFO, String.format( "InputFormat Definition found: >>>%s<<<", inputFormat));
          if (inputFormat.indexOf("RCFileInputFormat") > 0) {
            rowFormat = "BI";
            tableFormatType = 6;
          }
          if (inputFormat.indexOf("SequenceFileInputFormat") > 0) {
            tableFormatType = 7;
          }
        }
        
        // Extract outputformat definition
        p = Pattern.compile( HIVE_MD_OUTPUTFORMAT_REGEX );
        m = p.matcher( extendedTableInfo );
        String outputFormat;
        if (m.find()) {
          outputFormat = m.group(1);
          logger.log(Level.INFO, String.format( "OutputFormat Definition found: >>>%s<<<", outputFormat));
        }
        
        // Extract location
        p = Pattern.compile( HIVE_MD_LOCATION_REGEX );
        m = p.matcher( extendedTableInfo );
        String location;
        if (m.find()) {
          location = m.group(1);
          logger.log(Level.INFO, String.format( "Location found: >>>%s<<<", location));
        }
        
        if (true) {
          String sqltxt = SQL_UPDATE_TABLE_ROW_FORMAT;
          PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
          psTable.clearParameters();
          psTable.setString(2,iMod);
          psTable.setString(3,tableName);
          psTable.setString(1,rowFormat);
          psTable.executeUpdate();
          psTable.close();
        }
        
        if (true) {
          String sqltxt = SQL_UPDATE_TABLE_STORAGE_FORMAT;
          PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
          psTable.clearParameters();
          psTable.setString(5,iMod);
          psTable.setString(6,tableName);
          psTable.setInt(1,tableFormatType);
          Clob clobInputFormat = repoCx.createClob();
          clobInputFormat.setString(1, inputFormat);
          psTable.setClob(2,clobInputFormat);
          Clob clobOutputFormat = repoCx.createClob();
          clobOutputFormat.setString(1, outputFormat);
          psTable.setClob(3,clobOutputFormat);
          Clob clobLocation = repoCx.createClob();
          clobLocation.setString(1, location);
          psTable.setClob(4,clobLocation);
          psTable.executeUpdate();
          psTable.close();
        }

        // set Serde
        if (rowFormat.equals("SD")) {
          String serdeProp = "";
          p = Pattern.compile( HIVE_MD_SERDEINFO_REGEX );
          m = p.matcher( extendedTableInfo );
          if (m.find()) {
            String serdeInfo = m.group(1);
            logger.log(Level.INFO, String.format( "Serde Info found: >>>%s<<<", serdeInfo));
            
            p = Pattern.compile( HIVE_MD_SERDE_PROP_REGEX );
            m = p.matcher( serdeInfo );
            if (m.find()) {
              serdeProp = m.group(1);
              logger.log(Level.INFO, String.format( "Serde Prop found: >>>%s<<<", serdeProp));
              
              serdeProp = constructProp(serdeProp);
              logger.log(Level.INFO, String.format( "New Serde Prop found: >>>%s<<<", serdeProp));
            }
          }
          
          if (isNative) {
            String sqltxt = SQL_UPDATE_TABLE_SERDE;
            PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
            psTable.clearParameters();
            psTable.setString(3,iMod);
            psTable.setString(4,tableName);
            Clob clobSerde = repoCx.createClob();
            clobSerde.setString(1, serdeDef);
            psTable.setClob(1,clobSerde);
            Clob clobSerdeProp = repoCx.createClob();
            clobSerdeProp.setString(1, serdeProp);
            psTable.setClob(2,clobSerdeProp);
            psTable.executeUpdate();
            psTable.close();
          } else {
            String sqltxt = SQL_UPDATE_TABLE_STORAGE_PROP;
            PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
            psTable.clearParameters();
            psTable.setString(3,iMod);
            psTable.setString(4,tableName);
            Clob clobStorageHandler = repoCx.createClob();
            clobStorageHandler.setString(1, storageHandler);
            psTable.setClob(1,clobStorageHandler);
            Clob clobSerdeProp = repoCx.createClob();
            clobSerdeProp.setString(1, serdeProp);
            psTable.setClob(2,clobSerdeProp);
            psTable.executeUpdate();
            psTable.close();
          }
        }
        
        // set delimited
        if (rowFormat.equals("DL")) {
          String fieldDelim = "";
          String escapeDelim = "";
          String lineDelim = "";
          String colelctionDelim = "";
          String mapkeyDelim = "";
          String nullFormat = "";
          p = Pattern.compile( HIVE_MD_SERDEINFO_REGEX );
          m = p.matcher( extendedTableInfo );
          if (m.find()) {
            String serdeInfo = m.group(1);
            logger.log(Level.INFO, String.format( "Serde Info found: >>>%s<<<", serdeInfo));
            
            int start = serdeInfo.indexOf("field.delim=") + 12;
            int end = start;
            if (start - 12 > 0) {
              while (serdeInfo.charAt(end) != ',' && serdeInfo.charAt(end) != '}')
                end++;
              while (serdeInfo.charAt(end) == ',')
                end++;
              if (serdeInfo.charAt(end) == '}')
                fieldDelim = serdeInfo.substring(start, end);
              else
                fieldDelim = serdeInfo.substring(start, end-1)
              logger.log(Level.INFO, String.format( "Field Delim found: >>>%s<<<", fieldDelim));
            }
            
            start = serdeInfo.indexOf("escape.delim=") + 13;
            end = start;
            if (start - 13 > 0) {
              while (serdeInfo.charAt(end) != ',' && serdeInfo.charAt(end) != '}')
                end++;
              while (serdeInfo.charAt(end) == ',')
                end++;
              if (serdeInfo.charAt(end) == '}')
                escapeDelim = serdeInfo.substring(start, end);
              else
                escapeDelim = serdeInfo.substring(start, end-1)
              logger.log(Level.INFO, String.format( "Escape Delim found: >>>%s<<<", escapeDelim));
            }
            
            start = serdeInfo.indexOf("line.delim=") + 11;
            end = start;
            if (start - 11 > 0) {
              while (serdeInfo.charAt(end) != ',' && serdeInfo.charAt(end) != '}')
                end++;
              while (serdeInfo.charAt(end) == ',')
                end++;
              if (serdeInfo.charAt(end) == '}')
                lineDelim = serdeInfo.substring(start, end);
              else
                lineDelim = serdeInfo.substring(start, end-1)
              logger.log(Level.INFO, String.format( "Line Delim found: >>>%s<<<", lineDelim));
            }
            
            
            start = serdeInfo.indexOf("colelction.delim=") + 17;
            end = start;
            if (start- 17 > 0) {
              while (serdeInfo.charAt(end) != ',' && serdeInfo.charAt(end) != '}')
                end++;
              while (serdeInfo.charAt(end) == ',')
                end++;
              if (serdeInfo.charAt(end) == '}')
                colelctionDelim = serdeInfo.substring(start, end);
              else 
                colelctionDelim = serdeInfo.substring(start, end-1)
              logger.log(Level.INFO, String.format( "Colelction Delim found: >>>%s<<<", colelctionDelim));
            }
            
            start = serdeInfo.indexOf("mapkey.delim=") + 13;
            end = start;
            if (start - 13 > 0) {
              while (serdeInfo.charAt(end) != ',' && serdeInfo.charAt(end) != '}')
                end++;
              while (serdeInfo.charAt(end) == ',')
                end++;
              if (serdeInfo.charAt(end) == '}')
                mapkeyDelim = serdeInfo.substring(start, end);
              else 
                mapkeyDelim = serdeInfo.substring(start, end-1);
              logger.log(Level.INFO, String.format( "Mapkey Delim found: >>>%s<<<", mapkeyDelim));
            }
            
            start = serdeInfo.indexOf("serialization.null.format=") + 26;
            end = start;
            if (start - 26 > 0) {
              while (serdeInfo.charAt(end) != ',' && serdeInfo.charAt(end) != '}')
                end++;
              while (serdeInfo.charAt(end) == ',')
                end++;
              if (serdeInfo.charAt(end) == '}')
                nullFormat = serdeInfo.substring(start, end);
              else 
                nullFormat = serdeInfo.substring(start, end-1);
              logger.log(Level.INFO, String.format( "Null format found: >>>%s<<<", nullFormat));
            }
            
            String sqltxt = SQL_UPDATE_TABLE_DELIMITED;
            PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
            psTable.clearParameters();
            psTable.setString(7,iMod);
            psTable.setString(8,tableName);
            psTable.setString(1,fieldDelim);
            psTable.setString(2,escapeDelim);
            psTable.setString(3,lineDelim);
            psTable.setString(4,colelctionDelim);
            psTable.setString(5,mapkeyDelim);
            psTable.setString(6,nullFormat);
            psTable.executeUpdate();
            psTable.close();
          }
          
        }
        
        // Extract partitioning column definitions
        p = Pattern.compile( HIVE_MD_PARTITIONDEF_REGEX );
        m = p.matcher( extendedTableInfo );
        numOfPartitionColumns = 0;
        if (m.find()) {
            String sPartitionDef = m.group(1);
            logger.log(Level.INFO, String.format( "Partitioning Definition found: >>>%s<<<", sPartitionDef));

            // Do we have a non-empty partition definition?
            if (sPartitionDef != null && sPartitionDef.length()>0) {
                String sqltxt = SQL_UPDATE_COLUMNS_PAR;
                PreparedStatement psCol = repoCx.prepareStatement(sqltxt);

                p = Pattern.compile( HIVE_MD_PARTITIONCOLUMN_REGEX );
                m = p.matcher( sPartitionDef );
                while (m.find()) {
                    String sColName = m.group(1); 
                    String sDataType = m.group(2); 
                    String sRemark = m.group(3); 
                    logger.log(Level.INFO, String.format( "Partition Column found: name:%s, type:%s, remark:%s",sColName, sDataType, sRemark));
                    // Remember the paritioning column name
                    listOfPartitioningCols.add(sColName);

                    // Previously needed due to the Hive JDBC driver in Hive 0.7.0 not reporting back partitioning columns
                    // Insert column
                    // insertColumn(psCol, numOfPartitionColumns, tableName, sColName, sDataType, sRemark);

                    // Set FF HIVE_PARTITION_COLUMN
                    psCol.clearParameters();
                    <% if(isODI12cOrLater) { %>
                    psCol.setString(2,iMod);
                    <% } else { %>
                    psCol.setInt(2,Integer.valueOf(iMod));
                    <% } %>
                    psCol.setString(1,"1");
                    psCol.setString(3,tableName);
                    psCol.setString(4,sColName);
                    psCol.executeUpdate();

                    numOfPartitionColumns++;
                }
                psCol.close();
            }

        }

        // Extract bucket column definitions
        p = Pattern.compile( HIVE_MD_BUCKETDEF_REGEX );
        m = p.matcher( extendedTableInfo );
        if (m.find()) {
            String sClusteringDef = m.group(1);
            logger.log(Level.INFO, String.format( "Bucket Definition found: >>>%s<<<", sClusteringDef));

            // Do we have a non-empty clustering definition?
            if (sClusteringDef != null && sClusteringDef.length()>0) {
                String sqltxt = SQL_UPDATE_COLUMNS_CLU;
                PreparedStatement psCol = repoCx.prepareStatement(sqltxt);

                p = Pattern.compile( HIVE_MD_BUCKETCOLUMN_REGEX );
                m = p.matcher( sClusteringDef );
                while (m.find()) {
                    String sColName = m.group(1); 
                    logger.log(Level.INFO, String.format( "Cluster Column found: name:%s",sColName));
                    // Set FF HIVE_CLUSTER_COLUMN
                    psCol.clearParameters();
                    <% if(isODI12cOrLater) { %>
                    psCol.setString(2,iMod);
                    <% } else { %>
                    psCol.setInt(2,Integer.valueOf(iMod));
                    <% } %>
                    psCol.setString(3,tableName);
                    psCol.setString(4,sColName);
                    psCol.setString(1,"1");
                    psCol.executeUpdate();
                }
                psCol.close();
            }
        }


        // Extract number of buckets
        Pattern pBuckets = Pattern.compile( HIVE_MD_BUCKETS_REGEX );
        m = pBuckets.matcher( extendedTableInfo );
        Integer iBuckets = null;
        if (m.find()) {
            iBuckets = Integer.valueOf( m.group(1) );
            logger.log(Level.INFO, String.format("Number of bucket found: %d", iBuckets));
        }        
        // Set FF HIVE_BUCKETS
        if (iBuckets != null) {
            String sqltxt = SQL_UPDATE_TABLE_BUCKET;
            PreparedStatement psTable = repoCx.prepareStatement(sqltxt);
            psTable.clearParameters();
            <% if(isODI12cOrLater) { %>
            psTable.setString(2,iMod);
            <% } else { %>
            psTable.setInt(2,Integer.valueOf(iMod));
            <% } %>
            psTable.setString(3,tableName);
            psTable.setInt(1,iBuckets);
            psTable.executeUpdate();
            psTable.close();
        }


        // Extract sort column definitions
        p = Pattern.compile( HIVE_MD_SORTDEF_REGEX );
        m = p.matcher( extendedTableInfo );
        if (m.find()) {
            String sSortDef = m.group(1);
            logger.log(Level.INFO, String.format( "Sort Definition found: >>>%s<<<", sSortDef));

            // Do we have a non-empty sorting definition?
            if (sSortDef != null && sSortDef.length()>0) {
                int sortbyPos = 1;
                String sqltxt = SQL_UPDATE_COLUMNS_SORT;
                PreparedStatement psCol = repoCx.prepareStatement(sqltxt);

                p = Pattern.compile( HIVE_MD_SORTCOLUMN_REGEX );
                m = p.matcher( sSortDef );
                while (m.find()) {
                    String sColName = m.group(1); 
                    logger.log(Level.INFO, String.format( "Sort Column found: name:%s",sColName));
                    // Set FF HIVE_SORT_COLUMN
                    psCol.clearParameters();
                    <% if(isODI12cOrLater) { %>
                    psCol.setString(2,iMod);
                    <% } else { %>
                    psCol.setInt(2,Integer.valueOf(iMod));
                    <% } %>
                    psCol.setString(3,tableName);
                    psCol.setString(4,sColName);
                    psCol.setInt(1,sortbyPos++);
                    psCol.executeUpdate();
                }
                psCol.close();
            }
        }
        return numOfPartitionColumns;
    }

    private String constructProp(String serdeProp) {
      StringBuffer serdePropBuf = new StringBuffer();
      serdePropBuf.append("{\"");
      serdeProp = serdeProp.replace(" ", "");
      int pos = serdeProp.indexOf(",");
      while (pos > 0) {
        serdePropBuf.append(serdeProp.substring(0, pos));
        serdeProp = serdeProp.substring(pos+1);
        int posOfComma = serdeProp.indexOf(",");
        int posOfEqual = serdeProp.indexOf("=");
        if ((posOfEqual > 0) && (posOfComma > posOfEqual || posOfComma < 0)) {
          serdePropBuf.append("\",\"");          
        } else {
          serdePropBuf.append(", ");
        }
        pos = serdeProp.indexOf(",");
      }
      serdePropBuf.append(serdeProp);
      serdePropBuf.append("\"}");
      
      String newSerdeProp = serdePropBuf.toString();
      newSerdeProp = newSerdeProp.replace("=", "\"=\"");
      newSerdeProp = newSerdeProp.replace("\"\"", "\"");
      
      return newSerdeProp;
    }
}

/* End of RkmHive.java */

rev     = new RkmHive()]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_PROJECT.1]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[236fd394-6f34-48ff-9081-6e4dd9bea0f8]]></Field>
 <Field name="RefObjFQName" type="java.lang.String"><![CDATA[DEMO]]></Field>
 <Field name="RefObjFQType" type="java.lang.String"><![CDATA[SNP_PROJECT]]></Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String"><![CDATA[4]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_TXTHEADER.5985]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[874fda22-1cf4-4ad6-80a6-723da9687f47]]></Field>
 <Field name="RefObjFQName" type="java.lang.String">null</Field>
 <Field name="RefObjFQType" type="java.lang.String">null</Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_TXTHEADER.5986]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[4af7cb0d-daa0-40d9-9c56-fbb755a791a7]]></Field>
 <Field name="RefObjFQName" type="java.lang.String">null</Field>
 <Field name="RefObjFQType" type="java.lang.String">null</Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_TRT.300]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[23967aac-f1d6-432d-966e-1635d712c186]]></Field>
 <Field name="RefObjFQName" type="java.lang.String"><![CDATA[DEMO.RKM Hive]]></Field>
 <Field name="RefObjFQType" type="java.lang.String"><![CDATA[SNP_PROJECT.SNP_TRT]]></Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String"><![CDATA[4.8]]></Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_TXTHEADER.5987]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[8654a520-cae8-4703-861a-6aa511a9b6a3]]></Field>
 <Field name="RefObjFQName" type="java.lang.String">null</Field>
 <Field name="RefObjFQType" type="java.lang.String">null</Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_ORIGTXT.102]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String">null</Field>
 <Field name="RefObjFQName" type="java.lang.String">null</Field>
 <Field name="RefObjFQType" type="java.lang.String">null</Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_TXTHEADER.5988]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[5a96fa80-c234-42e5-b9ad-280620d30f11]]></Field>
 <Field name="RefObjFQName" type="java.lang.String">null</Field>
 <Field name="RefObjFQType" type="java.lang.String">null</Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.dbobj.SnpFKXRef">
		<Field name="RefKey" type="java.lang.String"><![CDATA[SNP_TXTHEADER.5989]]></Field>
	<Field name="RefObjGlobalId" type="java.lang.String"><![CDATA[903f8af7-cbd6-4521-b744-d01235ec63c6]]></Field>
 <Field name="RefObjFQName" type="java.lang.String">null</Field>
 <Field name="RefObjFQType" type="java.lang.String">null</Field>
 <Field name="RefObjFQNameLengths" type="java.lang.String">null</Field>
</Object>
<Object class="com.sunopsis.dwg.DwgExportSummary">
		<Field name="ExpTxtNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="InstObjNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="JoinColNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="JoinNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="KeyColNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="KeyNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="LinkDiagNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="MorigTxtNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="MtxtNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="OrigTxtNb" type="com.sunopsis.sql.DbInt"><![CDATA[5]]></Field>
	<Field name="OtherObjectsNb" type="com.sunopsis.sql.DbInt"><![CDATA[5]]></Field>
	<Field name="PlanAgentNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="StepNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="TxtNb" type="com.sunopsis.sql.DbInt"><![CDATA[5]]></Field>
	<Field name="UeOrigNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="UeUsedNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="VarPlanAgentNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="ScenTxtNb" type="com.sunopsis.sql.DbInt"><![CDATA[0]]></Field>
	<Field name="OdiVersion" type="java.lang.String"><![CDATA[12.2.1]]></Field>
	<Field name="OriginRepositoryID" type="com.sunopsis.sql.DbInt"><![CDATA[11]]></Field>
	<Field name="RepositoryVersion" type="java.lang.String"><![CDATA[05.02.02.09]]></Field>
</Object>
</SunopsisExport>
